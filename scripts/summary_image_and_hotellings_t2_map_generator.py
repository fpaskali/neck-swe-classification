#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Nov 1 10:05:10 2022

@author: fpaskali
"""

import argparse
import numpy as np
import numpy.ma as ma
import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import f
from statsmodels import robust
from skimage import io, color
from skimage.filters import threshold_otsu
from skimage.segmentation import clear_border
from skimage.measure import label, regionprops
from skimage.morphology import closing, square, erosion
from skimage.color import rgb2gray
from scipy.ndimage import zoom


class Image(object):
    """
    Object containing all information about an image, such as path to the 
    image file, path to the quality map file, subject number, number of repeat
    session, pain or control group and task. Furthermore, it contains a method 
    to detect region of interest and to crop the image using predefined height 
    and width parameters.

    Parameters
    ----------
    image_path : str
        path to image file.
    qmap_path : str
        path to the quality map file.
    subject : int
        the id of the subject.
    repeat : int
        the number of session.
    group : int
        the id of the trial group. (e.g. 0 = pain, 1 = control)
    task : str, optional
        the description of the task performed when image was obtained. 
    
    Attributes
    ----------
    color_perc : float
        the percentage of colored pixels in the image. 
    miny : int
        the row number where region of interest starts.  
    minx : int
        the column number where region of interest starts.
    maxy : int
        the row number where region of interest ends.
    maxx : int
        the column number where region of interest ends.
    image_array : numpy array
        numpy array of the image.
    qmap_array : numpy array
        numpy array of the quality map.
    """
    
    def __init__(self, image_path, qmap_path, subject, repeat, group, task):
        self.image_path = image_path
        self.qmap_path = qmap_path
        self.subject = subject
        self.repeat = repeat
        self.group = group
        self.task = task

        self.color_perc = 0
        self.miny = 0
        self.minx = 0
        self.maxy = 0
        self.maxx = 0

        self.image_array = None
        self.qmap_array = None

    def load_image(self):
        """
        Load the image from image path parameter.
        """
        self.image_array = io.imread(self.image_path)

    def load_qmap(self):
        """
        Load the quality map from qmap path parameter.
        """
        self.qmap_array = io.imread(self.qmap_path)

    def detect_colored_region(self):
        """
        Read the image and convert it to HSV image. Otsu threshold is applied
        on the saturation layer and enchance the threshold to remove artifacts
        connected to image borders. Then label the region of interest and save
        the parameters to miny, minx, maxy, maxx.
        """
        hsv_image = color.rgb2hsv(self.qmap_array)
        sat_image = hsv_image[:,:,1]

        thresh = 0.4
        bw = closing(sat_image > thresh, square(2))
        selem = square(2)
        eroded = erosion(bw, selem)
        
        label_image = label(eroded)

        for region in regionprops(label_image):
            if region.area >= 6000:
                self.miny, self.minx, self.maxy, self.maxx = region.bbox

    def crop_image(self, max_width, max_height):
        """
        Crop an area of the image, using predefined width and height parameters.
        The area is centered on the original image.

        Parameters
        ----------
        max_width : int
            the width of the cropped area.
        max_height : int
            the height of the area.
        """
        miny = (self.miny + self.maxy)//2 - max_height//2
        minx = (self.minx + self.maxx)//2 - max_width//2

        self.image_array = self.image_array[miny:miny+max_height,
                                            minx:minx+max_width]
    
    def use_only_colored_pix(self):
        """
        Convert non-colored pixels to np.nan, hopefully reducing the noise generated by ultrasound.
        """
        hsv_image = color.rgb2hsv(self.image_array)
        sat_image = hsv_image[:,:,1]
        
        thresh = 0.4
        bw = closing(sat_image > thresh, square(2))
        selem = square(2)
        eroded = erosion(bw, selem)
        
        color_map = np.zeros_like(self.image_array)
        for i in range(color_map.shape[-1]):
            color_map[:,:,i] = eroded
        
        new_image = np.zeros_like(self.image_array)
        
        new_image = np.where(color_map == 1, self.image_array, np.nan)

                        
        self.image_array = new_image
        
        
    def check_color_perc(self):
        sat_segment = color.rgb2hsv(self.image_array)[:,:,1]
        thresh = threshold_otsu(sat_segment)
        bw = np.where(sat_segment > thresh, 1, 0)
        self.color_perc = bw.sum()/bw.size

class SummaryImageCalc(object):
    """
    Calculate and plot summary image.

    Parameters
    ----------
    csv_file : str
        path to csv file containing images info.
    remove_low_color : bool
        if true remove images with color pixels less than 50%.
    """
    def __init__(self, csv_file, remove_low_color=False):
        self.csv_file = csv_file
        self.remove_low_color = remove_low_color
        self._load_dataset_csv()
        self._clean_image_list()

    def _load_dataset_csv(self):
        """
        Check csv file structure. If it is correct, load the data for all images.
        """
        lista = []
        dataset = pd.read_csv(self.csv_file, keep_default_na=False)
        
        if dataset.columns.size >= 5 and list(dataset.columns[:3]) == ['subject', 'repeat', 'group']:
            for i in range(3, dataset.columns.size, 2):
                for row in range(dataset.index.size):
                    lista.append(Image(dataset.iloc[row, i],
                                       dataset.iloc[row, i+1],
                                       dataset.iloc[row, 0],
                                       dataset.iloc[row, 1],
                                       dataset.iloc[row, 2],
                                       dataset.columns[i]))
            self.images = lista
        else:
            print("Invalid dataset file. The structure of the csv file is not correct")

    def _clean_image_list(self):
        """
        Remove Image objects without elastography images or without quality maps.
        """
        self.images = [x for x in self.images if x.image_path != '']
        self.images = [x for x in self.images if x.qmap_path != '']

    def _detect_roi(self):
        """
        Detect region of interest of all images in csv file.
        """
        i = 0
        for img in self.images:
            img.load_qmap()
            img.detect_colored_region()
            del img.qmap_array
            i += 1
            print(f'\rROI calculation...[{i}/{len(self.images)}]', end='')
        print()
    
    def _detect_roi_maxima(self):
        """
        Return the maximal height and width values of region of interest.

        Returns
        -------
        max_w : int
            maximal width of region of interest.
        max_h : int
            maximal height of region of interest.
        """
        max_h = np.max([x.maxy - x.miny for x in self.images])
        max_w = np.max([x.maxx - x.minx for x in self.images])
        
        return max_w, max_h

    def _detect_roi_minima(self):
        """
        Return the maximal height and width values of region of interest.

        Returns
        -------
        max_w : int
            maximal width of region of interest.
        max_h : int
            maximal height of region of interest.
        """
        min_h = int(np.median([x.maxy - x.miny for x in self.images]))
        min_w = int(np.median([x.maxx - x.minx for x in self.images]))
        
        return min_w, min_h
    
    def _load_and_crop_images(self, use_min=False):
        """
        Load and crop all images with calculated region of interest.
        """
        maxw, maxh = self._detect_roi_maxima()
        minw, minh = self._detect_roi_minima()
        i = 0
        for img in self.images:
            img.load_image()
            if not use_min:
                img.crop_image(maxw, maxh)
            else:
                img.crop_image(minw, minh)

            i += 1
            print(f'\rCropping...[{i}/{len(self.images)}]', end='')
        print()

    def _calculate_summary_images(self, image_arrays):
        """
        Calculate and return a list with mean, median, standard deviation and
        median absolute deviation summary images.

        Parameters
        ----------
        image_arrays : list
            a list with numpy arrays of images

        Returns
        -------
        list
            with mean, median, sd and MAD summary images as numpy arrays.
        """
        images = np.array(image_arrays)
        # Generating a mean image and a median image
        mean = np.array(np.nanmean(np.array(images), axis=0), dtype=np.uint8)
        median = np.array(np.nanmedian(np.array(images), axis=0), dtype=np.uint8)
        # SD and MAD
        sd = np.array(np.nanstd(images, axis=0), dtype=np.uint8)
        # mad = np.array(robust.mad(images, c=1, axis=0), dtype=np.uint8) # This function does not with missing values. It has to be addapted

        return mean, median, sd

    def _check_color_perc(self):
        """
        Measure the color percentage in each image.
        """
        i = 0
        for img in self.images:
            img.check_color_perc()
            i += 1
            print(f'\rChecking colored perc...[{i}/{len(self.images)}]', end='')
        print()
        
    def _transfer_color_pixs(self):
        """
        Transfer colored pixs to black background.
        """
        i = 0
        for img in self.images:
            img.use_only_colored_pix()
            i += 1
            print(f'\rTransfering colored pixels...[{i}/{len(self.images)}]', end='')
        print()
        
    def _get_h_segments(self, image_list, seg_num, total_seg):
        """
        Divide elastography image and red regions image in predefined number of
        equally sized horizontal segments. Yield segment of red region image and
        segment of elastography image.

        Parameters
        ----------
        num : int
            number of horizontal segments.

        Yields
        ------
        numpy array
            a horizontal segment of red regions image.
        numpy array
            a horizontal segment of elastography image.

        """
        height = image_list[0].image_array.shape[0]
        y = height // total_seg
        
        for img in image_list:
            img.image_array = img.image_array[y*(seg_num-1):y*(seg_num),:]
        
        return image_list

    def calculate_pixel_sums(self, tasks):
        pixel_names = [f'px_{i+1}' for i in range(int((self.images[0].image_array.shape[0]*0.25)*(self.images[0].image_array.shape[1]*0.25)))]
        table = pd.DataFrame(columns=['Image name', 'Subject', 'Group', 'Task', *pixel_names])
        c = 0
        images = [img for img in self.images if img.task in tasks]
        for img in images:
            pixels_info = {'Image name':img.image_path,
                           'Subject':img.subject,
                           'Group':img.group,
                           'Task':img.task,
                            }
            gray = rgb2gray(img.image_array)
            gray = zoom(input=gray, zoom=0.25)
            pixels_sum = gray.flatten()
            for i in range(len(pixels_sum)):
                pixels_info[f'px_{i+1}'] = pixels_sum[i]
                
            table = table.append(pd.DataFrame(data=pixels_info, index=[0]), ignore_index=True)
            c += 1
            print(f'\rCalculating pixel sum...[{c}/{len(images)}]', end='')
        print()
            
        return table
    
    def calculate_pixel_sums_by_segments(self, tasks, total_seg):
        images = [img for img in self.images if img.task in tasks]
        for seg in range(total_seg):
            c = 0
            segments = self._get_h_segments(images, seg+1,total_seg)
            pixel_names = [f'px_{i+1}' for i in range(segments[0].image_array.shape[0]*segments[0].image_array.shape[1])]
            pain = pd.DataFrame(columns=[*pixel_names])
            control = pd.DataFrame(columns=[*pixel_names])
            for img in segments:
                pixels_info = {}
                image = rgb2gray(img.image_array)
                pixels_sum = image.ravel()
                for i in range(len(pixels_sum)):
                    pixels_info[f'px_{i+1}'] = pixels_sum[i]
                if img.group == 0:
                    pain = pain.append(pd.DataFrame(data=pixels_info, index=[0]), ignore_index=True)
                else:
                    control = control.append(pd.DataFrame(data=pixels_info, index=[0]), ignore_index=True)
                c += 1
                print(f'\rCalculating pixel sum [Segment {seg+1}]...[{c}/{len(images)}]', end='')
            print()
            pain.to_csv(f"output/segments_{seg+1}_pain.csv")
            control.to_csv(f"output/segments_{seg+1}_control.csv")

    def _hotelling_t2(self, X,Y):
        nx, p = X.shape
        ny, _ = Y.shape
        delta = np.mean(X, axis=0) - np.mean(Y, axis=0)
        Sx = ma.cov(X, rowvar=False)
        Sy = ma.cov(Y, rowvar=False)
        S_pooled = ((nx-1)*Sx + (ny-1)*Sy)/(nx+ny-2)
        t_squared = (nx*ny)/(nx+ny) * np.matmul(np.matmul(delta.transpose(), np.linalg.inv(S_pooled)), delta)
        statistic = t_squared * (nx+ny-p-1)/(p*(nx+ny-2))
        F = f(p, nx+ny-p-1)
        p_value = 1 - F.cdf(statistic)
        
        return t_squared, p_value

    def generate_hotelling_heatmap(self, filename, images):
        # Find the size of the images by checking the size of the first image
        img_shape = images[1].image_array.shape

        # Generate empty binary mask
        hot_mask = np.full(img_shape[:-1], np.nan)

        count = 1
        for y in range(1,img_shape[0]):
            for x in range(1,img_shape[1]):
                print(f'\rGenerating hotelling mask...[{count/(img_shape[0]*img_shape[1])*100:.2f}%]', end='')
                
                p_rgb = []
                c_rgb = []

                for img in images:
                    if img.group == 0:
                        p_rgb.append(tuple(img.image_array[y,x,:]))
                    else:
                        c_rgb.append(tuple(img.image_array[y,x,:]))

                p_df = np.array(p_rgb)
                c_df = np.array(c_rgb)
                
                # Exclude pixels with missing more than 10% of the pixels
                ex_limit = len(p_df) * 0.90
                if np.sum([np.isnan(p_df[i,]).all() for i in range(len(p_df))]) > ex_limit:
                    p_df = None
                if np.sum([np.isnan(c_df[i,]).all() for i in range(len(c_df))]) > ex_limit:
                    c_df = None

                try:
                    p_df = ma.masked_invalid(p_df)
                    c_df = ma.masked_invalid(c_df)
                    t2, p_val = self._hotelling_t2(p_df,c_df)
                except:
                    p_val = np.nan
                finally:
                    hot_mask[y,x] = p_val

                count += 1
        print()

        io.imsave(f"output/{filename}_hotelling_mask.png", hot_mask)
        bin_mask1 = np.where(hot_mask < 0.05, 1, 0)
        bin_mask2 = np.where(hot_mask < 0.01, 1, 0)

        bin_mask = bin_mask1 + bin_mask2

        plt.imsave(f"output/{filename}_hotelling_bin_mask.png", bin_mask)

    def preprocess(self, use_min):
        """
        Prepare images for plotting.
        """
        self._detect_roi()
        self._load_and_crop_images(use_min=use_min)
        self._transfer_color_pixs()
        if self.remove_low_color:
            self._check_color_perc()
            self.images = [x for x in self.images if x.color_perc > 0.5]
        print("Total images:", len(self.images))
        print("Pain:", len([x for x in self.images if x.group == 0]))
        print("Control:", len([x for x in self.images if x.group == 1]))
        
    def plot_summary_images(self, images):
        """
        Plot summary images of pain and control in one figure, then show it.
        """
        pain_images = np.array([x.image_array for x in images if x.group == 0])
        control_images = np.array([x.image_array for x in images if x.group == 1])

        pain_summaries = self._calculate_summary_images(pain_images)
        control_summaries = self._calculate_summary_images(control_images)
        name_summaries = ['Mean', 'Median', 'SD']

        for p, c, n in zip(pain_summaries, control_summaries, name_summaries):
            fig, (ax0, ax1) = plt.subplots(ncols=2, figsize=(8, 5))
            ax0.imshow(c)
            ax0.set_title(f"Control ({n} Summary Image)")
            ax0.axis('off')
            ax1.imshow(p)
            ax1.set_title(f"Pain ({n} Summary Image)")
            ax1.axis('off')
            fig.tight_layout()

            plt.show()
            
    def save_summary_images(self, filename, images):
        """
        Plot summary images of pain and control in one figure, then show it.
        """
        pain_images = np.array([x.image_array for x in images if x.group == 0])
        control_images = np.array([x.image_array for x in images if x.group == 1])

        pain_summaries = self._calculate_summary_images(pain_images)
        control_summaries = self._calculate_summary_images(control_images)
        name_summaries = ['Mean', 'Median', 'SD']

        for p, c, n in zip(pain_summaries, control_summaries, name_summaries):
            fig, (ax0, ax1) = plt.subplots(ncols=2, figsize=(8, 5))
            ax0.imshow(c)
            ax0.set_title(f"Control ({n} Summary Image)")
            ax0.axis('off')
            ax1.imshow(p)
            ax1.set_title(f"Pain ({n} Summary Image)")
            ax1.axis('off')
            fig.tight_layout()

            plt.savefig(f'output/{filename}_{n}.png', )
            plt.close()
        
        print("Pain images:", len(pain_images))
        print("Control images:", len(control_images))

    def tasks_from_csv(self, csv_info):
        # FIXME Check why this function crashes the script. The process is killed in linux terminal.
        csv_info = pd.read_csv(csv_info)

        for i in range(len(csv_info.columns)):
            name = csv_info.columns[i]
            tasks = list(csv_info.iloc[:,i])
            
            images = [x for x in self.images if x.task in tasks]
            self.save_summary_images(name, images)
            self.generate_hotelling_heatmap(name, images)
            print("Task group:", name)
            print("Tasks: ", tasks)
            print("Image number: ", len(images))

    def user_interface(self):
        """
        User interface used for choosing filters.
        """
        filter_list = list(set([x.task for x in self.images]))
        filter_list.sort()
        for i in range(len(filter_list)):
            print(f'{i+1}) {filter_list[i]}')
        print('Choose task.(More tasks can be chosen, separated by comma)')
        print('To select all, write "ALL".')
        choice = input('>')
        if choice.upper() == 'ALL':
            images = self.images
            self.save_summary_images(images)
            self.generate_hotelling_heatmap("all", images)
        elif choice.upper() == 'TASK':
            for task in filter_list:
                images = [x for x in self.images if x.task == task]
                print("Filters chosen:", task)
                self.save_summary_images(task, images)
                self.generate_hotelling_heatmap(task, images)
        else:
            choice = choice.split(',')
            filters = []
            for i in choice:
                i = int(i) - 1
                filters.append(filter_list[i])
            images = [x for x in self.images if x.task in filters]
            print("Filters chosen:", filters)
            self.generate_hotelling_heatmap("task", images)
            self.save_summary_images(images)
        

def main():
    parser = argparse.ArgumentParser(description="Summary image generator")
    parser.add_argument("-data", help="CSV file with images info.")
    parser.add_argument("-r", help="Remove all images with less than 50 percent colored pixels.", action="store_true", default=False)
    parser.add_argument("-tasks", help="Read in the tasks from CSV file.")
    parser.add_argument("-inter", help="Use intersection of ROI instead of the largest ROI when cropping the images.", action="store_true", default=True)
    args = parser.parse_args()
    sumarizer = SummaryImageCalc(args.data, args.r)

    sumarizer.preprocess(args.inter)

    if args.tasks == None:
        sumarizer.user_interface()
    else:
        sumarizer.tasks_from_csv(args.tasks)
        
if __name__ == "__main__":
    main()